<#
Author: Soteria-Se, Leonardo van de Weteringh
Copright: 2022
Version: 0.0.9 beta
Usage: ./365Inspect+.ps1 or ./365Inspect+.exe
Date: 17-08-2022
#>

<#
  .SYNOPSIS
  Performs an Microsoft 365 Security Assessment.

  .DESCRIPTION
  Automate the security assessment of Microsoft 365 environments.

  .PARAMETER OrgName
  The name of the core organization or "company" of your M365 instance, which will be inspected.
  e.g. yourcompany

  .PARAMETER OutPath
  The path to a folder where another folder with the report is generated by 365Inspect will be placed.
  e.g. C:\output

  .PARAMETER MFA
  A switch that would check if MFA needs to be used for authentication

  .PARAMETER Username
  Username of O365 account.
  e.g. example@yourcompany.com

  .PARAMETER Password
  Password of O365 account.

  .PARAMETER SkipUpdateCheck
  Skips Update Checking and Installing of Programs

  .INPUTS
  None. You cannot pipe objects to 365Inspect.ps1.

  .OUTPUTS
  None. 365Inspect.ps1 does not generate any output.

  .EXAMPLE
  PS> .\365Inspect.ps1
#>

param(
  [Parameter(Mandatory = $true,
    HelpMessage = 'Organization Name, e.g. contoso')]
  [string]$OrgName,
  [Parameter(Mandatory = $true,
    HelpMessage = 'Path to store the report, e.g. C:\out')]
  [string]$OutPath,
  [Parameter(Mandatory = $false,
    HelpMessage = 'Enter Global Administrator Username')]
  [string]$Username,
  [Parameter(Mandatory = $false,
    HelpMessage = 'Enter Global Administrator Password')]
  [string]$Password,
  [Parameter(Mandatory = $true,
    HelpMessage = "ReportTypeFormat: HTML / CSV / XML")]
  [ValidateSet("HTML", "CSV", "XML",
    IgnoreCase = $true)]
  [string] $reportType = "HTML",
  [Parameter(Mandatory = $false,
    HelpMessage = 'Skip Update Check')]
  [switch]$SkipUpdateCheck,
  [Parameter(Mandatory = $false,
    HelpMessage = 'Auth Type')]
  [string[]]$SelectedInspectors = @(),
  [string[]]$ExcludedInspectors = @()
)

$org_name = $OrgName
$out_path = $OutPath
$user_name = $Username
$pass_word = $Password
$selected_inspectors = $SelectedInspectors
$excluded_inspectors = $ExcludedInspectors
$ConnectedServices = ""



function CheckAdminPrivBeta {
  # Check if script is running as Adminstrator and if not use RunAs
  Write-Host "[...] Checking if the script is running as Administrator"
  $IsAdmin = ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]"Administrator")
  if (-not $IsAdmin) {
    Write-Host "[!] The script is NOT running as Administrator, restarting PowerShell as Administrator..." -ForegroundColor Red
    try {
      $cmd = $PSCommandPath + " -OrgName $OrgName -OutPath $OutPath -reportType $reportType"
      if (-not [string]::IsNullOrEmpty($user_name)) {
        $cmd = $cmd + " -username " + $Username
      }
      if (-not [string]::IsNullOrEmpty($pass_word)) {
        $cmd = $cmd + " -password " + $Password
      }
      if ($SkipUpdateCheck.IsPresent) {
        $cmd = $cmd + " -SkipUpdateCheck"
      }
      $arguments = "-NoProfile -NoExit -Command ""& {$cmd} """
      Start-Process "$psHome\powershell.exe" -Verb Runas -ArgumentList $arguments -ErrorAction Stop
      break
    } catch {
      Write-Warning "[!] Program needs Administrator Rights! You cannot run this in normal user mode!"
      break
    }
  }
  else {
    Write-Host "[+] The script is running as Administrator..." -ForegroundColor Green
  }
}


function CheckInstalledModules {
  if (-not $SkipUpdateCheck.IsPresent) {
    Write-Warning "[?] Checking Installed Modules..."
    # Define the set of modules installed and updated from the PowerShell Gallery that we want to maintain
    $O365Modules = @("MicrosoftTeams","MSOnline","Az","AzureADPreview","ExchangeOnlineManagement","Microsoft.Online.Sharepoint.PowerShell","Microsoft.Graph","Microsoft.Graph.Intune","PnP.PowerShell")
    #Check which Modules are Installed Already...
    $installed = Get-InstalledModule
    foreach ($module in $O365Modules) {
      if ($installed.Name -notcontains $module) {
        Write-Host "`n$module is not installed." -ForegroundColor Red
        Write-Warning 'The module may be installed by running "Install-Module $module -Force -Scope CurrentUser -Confirm:$false" in an elevated PowerShell window.'
        $install = Read-Host -Prompt "Would you like to attempt installation now? (Y|N)"
        if ($install -eq 'y') {
          Install-Module $module -Scope CurrentUser -Force -Confirm:$false
          $count++
        }
      } else {
        Write-Host "[+] $module is installed." -ForegroundColor Green
        $count++
      }
    }

    # Get all installed modules that have a newer version available
    $Modules = @("MicrosoftTeams","MSOnline","Az","AzureADPreview","ExchangeOnlineManagement","Microsoft.Online.Sharepoint.PowerShell","Microsoft.Graph","Microsoft.Graph.Intune","PnP.PowerShell")
    $PowerShellGetVersion = Get-InstalledModule -Name "PowerShellGet" -ErrorAction Stop
    Write-Host "Checking all installed modules for available updates."
    $CurrentModules = Get-InstalledModule | Where-Object { $Modules -contains $_.Name}

    $CurrentModules | ForEach-Object {
    Write-Host "[>] Checking $($_.Name) ..."
            Try {
            $GalleryModule = Find-Module -Name $_.Name -Repository PSGallery -ErrorAction SilentlyContinue #-AllowPreRelease
        }
        Catch {
            Write-Error "Module $($_.Name) not found in gallery $_"
            $GalleryModule = $null
            continue
        }
       if ($GalleryModule.Version -gt $_.Version) {
       Write-Host "$($_.Name) will be updated. Galleryversion: $($GalleryModule.Version), Localversion $($_.Version)"
                       try {
                    if ($PSCmdlet.ShouldProcess(("Module {0} will be updated to version {1}" -f $_.Name, $GalleryModule.Version),$_.Name,"Update-Module"))
                    {
                        Update-Module $_.Name -ErrorAction SilentlyContinue -Force
                        Write-Host "$($_.Name)  has been updated!" -ForegroundColor Green
                    }
                }
                Catch {
                    Write-Error "$($_.Name) failed: $_ "
                    continue

                }
       }                     
       elseif (($null -ne $GalleryModule) -or ($GalleryModule.Version -le $_.Version)) {
            Write-Warning "$($_.Name) is up to date!"
            }
        }

        #Uninstall Modules
        Write-Host "Checking all installed modules for multiple versions..."
        $CurrentModules | ForEach-Object {
        if ((Get-InstalledModule -Name $_.Name -AllVersions).Count -igt 1){
        $getallversions = @(Get-InstalledModule -Name $_.Name -AllVersions | Select Version)
        #Unused parts of script need to be eliminated later
                        try {
                                $GalleryModule = Find-Module -Name $_.Name -ErrorAction Stop         
                                if ($PowerShellGetVersion.Version -igt 2.2.5) {
                                foreach ($version in $getallversions){
                                if ($version.Version -ne $GalleryModule.Version){
                                Write-Host "Trying to Uninstall version $($version.Version) of $($_.Name)..."
                                Uninstall-PSResource -Name $_.Name -Version $version.Version -ErrorAction Stop
                                Write-Host "Version $($version.Version) of $($_.Name) has been removed!" -ForegroundColor Green
                                }
                                }
                                }else{
                                Write-Host "Trying to Uninstall $($_.Name)..."
                                Get-InstalledModule -Name $_.Name -AllVersions | Where-Object { $_.version -ne $GalleryModule.Version } | Uninstall-Module -Force -ErrorAction Stop
                                Write-Host "Old versions of $($_.Name) have been removed!" -ForegroundColor Green
                                }
                        }
                        catch {
                            Write-Error "Uninstalling old module $($_.Name) failed: $_"
                        }
                        }else{
                        Write-Warning "Module $($_.Name) has no multiple versions!"
                        }
                        }
    #END SCRIPT
  }
}

function Exception {
  if (-not (Get-Variable -Name 'PSScriptRoot' -Scope 'Script')) {
    $Script:PSScriptRoot = Split-Path -Path $MyInvocation.MyCommand.Definition -Parent
  }
  if ($psISE) {
    .(Join-Path (Split-Path -Path $psISE.CurrentFile.FullPath) Write-ErrorLog.ps1)
  } else {
    .(Join-Path $PSScriptRoot Write-ErrorLog.ps1)
  }
  Write-Warning "Error message: $_"
  $message = $_.ToString()
  $exception = $_.Exception
  $strace = $_.ScriptStackTrace
  $failingline = $_.InvocationInfo.Line
  $positionmsg = $_.InvocationInfo.PositionMessage
  $pscommandpath = $_.InvocationInfo.PSCommandPath
  $failinglinenumber = $_.InvocationInfo.ScriptLineNumber
  $scriptname = $_.InvocationInfo.ScriptName
  Write-Verbose "Write to log"
  Write-ErrorLog -Message $message -Exception $exception -scriptname $scriptname -failinglinenumber $failinglinenumber -failingline $failingline -pscommandpath $pscommandpath -positionmsg $pscommandpath -stacktrace $strace
  Write-Verbose "Errors written to log"
}

function Connect-Services {

<# Add Commands to connect to respective Module here #>
if (-not [string]::IsNullOrEmpty($Username) -and -not [string]::IsNullOrEmpty($Password)){ #Authentication Username + Password 
#Store Credentials in Variable
try {$SecuredPassword = ConvertTo-SecureString -AsPlainText $Password -Force
$Credential = New-Object System.Management.Automation.PSCredential $UserName,$SecuredPassword}catch{Write-Error "Could Not Convert Credentials!"}
$commands = @('$Team = Connect-MicrosoftTeams -Credential $Credential -ErrorAction Stop','Connect-AzAccount -Credential $Credential -ErrorAction Stop | Out-Null',
'Connect-MsolService -Credential $Credential -ErrorAction Stop','Connect-AzureAD -Credential $Credential -ErrorAction Stop | Out-Null',
'Connect-ExchangeOnline -Credential $Credential -ShowBanner:$false -ErrorAction Stop','Connect-SPOService -Url "https://$org_name-admin.sharepoint.com" -Credential $Credential -ErrorAction Stop',
'Connect-MSGraph -AdminConsent -ErrorAction Stop | Out-Null','Connect-PnPOnline -ErrorAction Stop -Url "https://$org_name.sharepoint.com" -Credentials $Credential',
'$MSGraph = Connect-MgGraph -ErrorAction Stop -Scopes "AuditLog.Read.All","Policy.Read.All","Directory.Read.All","IdentityProvider.Read.All","Organization.Read.All","Securityevents.Read.All","ThreatIndicators.Read.All","SecurityActions.Read.All","User.Read.All","UserAuthenticationMethod.Read.All","MailboxSettings.Read"',
'Connect-IPPSSession -Credential $Credential -WarningAction SilentlyContinue -ErrorAction Stop')

}elseif(-not [string]::IsNullOrEmpty($Username)){ #NON MFA, but Username is known!
$commands = @('$Team = Connect-MicrosoftTeams -AccountId $Username','Connect-AzAccount -AccountId $Username | Out-Null',
'Connect-MsolService -ErrorAction Stop','Connect-AzureAD -AccountId $Username -ErrorAction Stop | Out-Null',
'Connect-ExchangeOnline -UserPrincipalName $Username -ShowBanner:$false',
'Connect-SPOService -Url "https://$org_name-admin.sharepoint.com" -ErrorAction Stop',
'Connect-MSGraph -AdminConsent -ErrorAction Stop | Out-Null','Connect-PnPOnline -ErrorAction Stop -Url "https://$org_name.sharepoint.com" -Interactive',
'$MSGraph = Connect-MgGraph -ErrorAction Stop -Scopes "AuditLog.Read.All","Policy.Read.All","Directory.Read.All","IdentityProvider.Read.All","Organization.Read.All","Securityevents.Read.All","ThreatIndicators.Read.All","SecurityActions.Read.All","User.Read.All","UserAuthenticationMethod.Read.All","MailboxSettings.Read"',
'Connect-IPPSSession -ErrorAction Stop -UserPrincipalName $Username -WarningAction SilentlyContinue')

}else{ #MFA Authentication NO PASSWORD NO USERNAME
$commands = @('$Team = Connect-MicrosoftTeams','Connect-AzAccount -ErrorAction Stop | Out-Null','Connect-MsolService -ErrorAction Stop',
'Connect-AzureAD -ErrorAction Stop | Out-Null','Connect-ExchangeOnline -ShowBanner:$false -ErrorAction Stop',
'Connect-SPOService -ErrorAction Stop -Url "https://$org_name-admin.sharepoint.com"','Connect-MSGraph -AdminConsent -ErrorAction Stop | Out-Null',
'Connect-PnPOnline -ErrorAction Stop -Url "https://$org_name.sharepoint.com" -Interactive',
'$MSGraph = Connect-MgGraph -ErrorAction Stop -Scopes "AuditLog.Read.All","Policy.Read.All","Directory.Read.All","IdentityProvider.Read.All","Organization.Read.All","Securityevents.Read.All","ThreatIndicators.Read.All","SecurityActions.Read.All","User.Read.All","UserAuthenticationMethod.Read.All","MailboxSettings.Read"',
'Connect-IPPSSession -WarningAction SilentlyContinue -ErrorAction Stop')
}

<# Validation Scripts in order to determine if connection has been successful! #>
$validation = @('-not [string]::IsNullOrEmpty($Team)','Get-AzAccessToken','(Get-MsolUser -MaxResults 1) -ne $null',
'(Get-AzureADUser -Top 1) -ne $null','(Get-EXOMailbox -ResultSize 1) -ne $null',
'(Get-SPOTenant) -ne $null','(Get-IntuneManagedDevice -Top 1) -ne $null','Get-PnpTenantInstance',
'$MSGraph -contains "Welcome To Microsoft Graph!"','$Result = Get-RetentionCompliancePolicy; ($?) -eq $true')

<# Add the new name here#>
$programs = @("Microsoft Teams","Microsoft Azure PowerShell","Microsoft Online Service","Microsoft Azure Active Directory",
"Microsoft Exchange Online","Microsoft Sharepoint Online","Microsoft InTune","Microsoft PowerShell PnP","Microsoft Graph",
"Microsoft Exchange Security & Compliance Center")

#To not do a for-loop, but to enable iteration inside a foreach loop that is parallel with the other functions
$i = 0
$j = 0

<# Actual Script #> 
foreach ($command in $commands){
try{Write-Host "Connecting to $($programs[$i])..."; iex $command}catch{Write-Error "Could not Connect!"}
if (iex $validation[$j]){
Write-Host "Connected to: $($programs[$i])!" -ForegroundColor DarkYellow -BackgroundColor Black
$i++
$j++
}else{
Write-Error "Could not Connect!"
$i++
$j++
break
}
}

}


function ExecuteInspectors() {
  
  $startdate = (Get-Date)
  # Get a list of every available detection module by parsing the PowerShell
  # scripts present in the .\inspectors folder. 
  #Exclude specified Inspectors
  if ($excluded_inspectors -and $excluded_inspectors.Count) {
    $excluded_inspectors = foreach ($inspector in $excluded_inspectors) { "$inspector.ps1" }
    $inspectors = (Get-ChildItem $PSScriptRoot\inspectors\*.ps1 -Exclude $excluded_inspectors).Name | ForEach-Object { ($_ -split ".ps1")[0] }
  }
  else {
    $inspectors = (Get-ChildItem $PSScriptRoot\inspectors\*.ps1).Name | ForEach-Object { ($_ -split ".ps1")[0] }
  }

  #Use Selected Inspectors
  if ($selected_inspectors -and $selected_inspectors.Count) {
    "The following inspectors were selected for use: "
    foreach ($inspector in $selected_inspectors) {
      Write-Host $inspector
    }
  }
  elseif ($excluded_Inspectors -and $excluded_inspectors.Count) {
    $selected_inspectors = $inspectors
    Write-Host "Using inspectors:`n"
    foreach ($inspector in $inspectors) {
      Write-Host $inspector
    }
  }
  else {
    Write-Host "Using all inspectors!"
    $selected_inspectors = $inspectors
  }

  # Maintain a list of all findings, beginning with an empty list.
  $findings = @()

  # For every inspector the user wanted to run...
  foreach ($selected_inspector in $selected_inspectors) {
    try {
      # ...if the user selected a valid inspector...
      if ($inspectors.Contains($selected_inspector)) {
        Write-Host "Invoking Inspector: $selected_inspector"

        # Get the static data (finding description, remediation etc.) associated with that inspector module.
        $finding = Get-Content $PSScriptRoot\inspectors\$selected_inspector.json | Out-String | ConvertFrom-Json

        # Invoke the actual inspector module and store the resulting list of insecure objects.
        $finding.AffectedObjects = Invoke-Expression "$PSScriptRoot\inspectors\$selected_inspector.ps1"

        # Add the finding to the list of all findings.
        $findings += $finding
      }
    }
    catch {
      Exception
    }
  }
  $executeinspectorsobject = New-Object PSObject -Property @{
  Findings = $findings
  StartDate = $startdate
  Inspectors = $selected_inspectors
  }
  return $executeinspectorsobject
  }

function GenerateReport($object){
# Define the Object values
$findings = $object.Findings
$startdate = $object.StartDate
$inspectors = $object.Inspectors
$selected_inspectors = $object.Inspectors

If ($reportType -eq "HTML"){
$templates = Parse-Template

# Maintain a running list of each finding, represented as HTML
  $short_findings_html = '' 
  $long_findings_html = ''

  $findings_count = 0
  $critical_count = 0
  $high_count = 0
  $medium_count = 0
  $low_count = 0
  $informational_count = 0


#Sort Object on CVS Score
$sortedFindings = $findings | Sort-Object {$_.CVS} -Descending
#Sort Object based on Impact
##$sortedFindings = $findings | Sort-Object {Switch -Regex ($_.Impact){'Critical' {1}	'High' {2}	'Medium' {3}	'Low' {4}	'Informational' {5}};$_.FindingName} 

ForEach ($finding in $sortedFindings) {
	# If the result from the inspector was not $null,
	# it identified a real finding that we must process.
	If ($null -NE $finding.AffectedObjects) {
		# Increment total count of findings
		$findings_count += 1
		
		# Keep an HTML variable representing the current finding as HTML
		$short_finding_html = $templates.FindingShortTemplate
		$long_finding_html = $templates.FindingLongTemplate
		
		# Insert finding name and number into template HTML
		$short_finding_html = $short_finding_html.Replace("{{FINDING_NAME}}", $finding.FindingName)
		$short_finding_html = $short_finding_html.Replace("{{FINDING_NUMBER}}", $findings_count.ToString())
		$long_finding_html = $long_finding_html.Replace("{{FINDING_NAME}}", $finding.FindingName)
		$long_finding_html = $long_finding_html.Replace("{{FINDING_NUMBER}}", $findings_count.ToString())
		
		# Finding Impact
		$short_finding_html = $short_finding_html.Replace("{{IMPACT}}", $finding.Impact)
		$long_finding_html = $long_finding_html.Replace("{{IMPACT}}", $finding.Impact)


        # Statistics for user information
        if ($finding.Impact -like "*Critical*") {
          $long_finding_html = $long_finding_html.Replace("{{IMPACT_COLOR}}", "8b0000")
          $critical_count += 1
        } elseif ($finding.Impact -like "*High*") {
          $long_finding_html = $long_finding_html.Replace("{{IMPACT_COLOR}}", "ff0000")
          $high_count += 1
        } elseif ($finding.Impact -like "*Medium*") {
          $long_finding_html = $long_finding_html.Replace("{{IMPACT_COLOR}}", "f6be00")
          $medium_count += 1
        } elseif ($finding.Impact -like "*Low*") {
          $long_finding_html = $long_finding_html.Replace("{{IMPACT_COLOR}}", "008000")
          $low_count += 1
        } elseif ($finding.Impact -like "*Informational*") {
          $long_finding_html = $long_finding_html.Replace("{{IMPACT_COLOR}}", "0000ff")
          $informational_count += 1
        }
		
        # Finding CVS Score
        $short_finding_html = $short_finding_html.Replace("{{CVS}}",$finding.CVS.ToString())
        $long_finding_html = $long_finding_html.Replace("{{CVS}}",$finding.CVS.ToString())

        #Finding Product Family
        $long_finding_html = $long_finding_html.Replace("{{PRODUCT_FAMILY}}",$finding.ProductFamily)

        # Finding description
        $long_finding_html = $long_finding_html.Replace("{{DESCRIPTION}}",$finding.Description)

        # Finding default value
        $long_finding_html = $long_finding_html.Replace("{{DEFAULTVALUE}}",$finding.DefaultValue)

        # Finding expected value
        $long_finding_html = $long_finding_html.Replace("{{EXPECTEDVALUE}}",$finding.ExpectedValue)

        # Finding Residual risk
        ##$long_finding_html = $long_finding_html.Replace("{{RISKRATING}}",$finding.RiskRating)
				
		# Finding Remediation
		If ($finding.Remediation.length -GT 300) {
			$short_finding_text = "Complete remediation advice is provided in the body of the report. Clicking the link to the left will take you there."
		}
		Else {
			$short_finding_text = $finding.Remediation
		}
		
		$short_finding_html = $short_finding_html.Replace("{{REMEDIATION}}", $short_finding_text)
		$long_finding_html = $long_finding_html.Replace("{{REMEDIATION}}", $finding.Remediation)
		
		# Affected Objects
		If ($finding.AffectedObjects.Count -GT 15) {
			$condensed = "<a href='{name}'>{count} Affected Objects Identified<a/>."
			$condensed = $condensed.Replace("{count}", $finding.AffectedObjects.Count.ToString())
			$condensed = $condensed.Replace("{name}", $finding.FindingName)
			$affected_object_html = $templates.AffectedObjectsTemplate.Replace("{{AFFECTED_OBJECT}}", $condensed)
			$fname = $finding.FindingName
			$finding.AffectedObjects | Out-File -FilePath $out_path\$fname
		}
		Else {
			$affected_object_html = ''
			ForEach ($affected_object in $finding.AffectedObjects) {
				$affected_object_html += $templates.AffectedObjectsTemplate.Replace("{{AFFECTED_OBJECT}}", $affected_object)
			}
		}
		
		$long_finding_html = $long_finding_html.Replace($templates.AffectedObjectsTemplate, $affected_object_html)
		
		# References
		$reference_html = ''
		ForEach ($reference in $finding.References) {
			$this_reference = $templates.ReferencesTemplate.Replace("{{REFERENCE_URL}}", $reference.Url)
			$this_reference = $this_reference.Replace("{{REFERENCE_TEXT}}", $reference.Text)
			$reference_html += $this_reference
		}
		
		$long_finding_html = $long_finding_html.Replace($templates.ReferencesTemplate, $reference_html)
		
		# Add the completed short and long findings to the running list of findings (in HTML)
		$short_findings_html += $short_finding_html
		$long_findings_html += $long_finding_html
	}
}

# Insert command line execution information. This is coupled kinda badly, as is the Affected Objects html.
    $flags = "<b>Audited Organization:</b> <u>" + $org_name + "</u><br/><br/>"
    $flags = $flags + "<b>Audit Started on:</b><i>"+ $startdate + "</i><br/>"
    $flags = $flags + "<b>Audit Finished on:</b><i> "+ (Get-Date) + "</i><br/><br/>"
    $flags = $flags + "<b>Stats</b>:<br/> <b>" + $findings_count + "</b> out of <b>" + $inspectors.Count + "</b> executed inspector modules identified possible opportunities for improvement.<br/><br/>"  
    $flags = $flags + "<font color='#8b0000'><b>Critical</b></font>: <b><u>" + $critical_count + "</b></u><font color='red'><b> High</b></font>: <b><u>" + $high_count + "</b></u><font color='#f6be00'><b> Medium</b></font>: <b><u>" + $medium_count + "</b></u><font color='green'><b> Low</b></font>: <b><u>" + $low_count + "</b></u><font color='blue'><b> Informational</b></font>: <b><u>" + $informational_count + "</b></u><br/><br/>"
    $flags = $flags + "<b>Inspector Modules Executed</b>:<br/>" + [String]::Join("<br/>", $selected_inspectors)

$output = $templates.ReportTemplate.Replace($templates.FindingShortTemplate, $short_findings_html)
$output = $output.Replace($templates.FindingLongTemplate, $long_findings_html)
$output = $output.Replace($templates.ExecsumTemplate, $templates.ExecsumTemplate.Replace("{{CMDLINEFLAGS}}", $flags))

$filename = "$out_path\Report_$(Get-Date -Format "yyyy-MM-dd_hh-mm-ss")_$org_name.html"
$output | Out-File -FilePath $filename
return $filename
}
Elseif ($reportType -eq "CSV"){
    $sortedFindings = $findings | Sort-Object {$_.CVS} -Descending
    #$sortedFindings = $findings | Sort-Object {Switch -Regex ($_.Impact){'Critical' {1}	'High' {2}	'Medium' {3}	'Low' {4}	'Informational' {5}};$_.FindingName}

    $results = @()

    $findings_count = 0

    foreach ($finding in $sortedFindings){
        If ($null -NE $finding.AffectedObjects) {
            $findings_count += 1

            $refs = @()

            foreach ($ref in $finding.References){
                $refs += "$($ref.Text) : $($ref.Url)"
            }

             $result = New-Object PSObject -ErrorAction SilentlyContinue -Property @{
             ID = $findings_count.ToString()
             FindingName = $finding.FindingName
             ProductFamily = $finding.ProductFamily
             Impact = $finding.Impact
             CVS = $finding.CVS.ToString()
             DefaultValue = $finding.DefaultValue
             ExpectedValue = $finding.ExpectedValue
            }
            $results += $result
            # Finding, AffectedObjects and References are buggy. Delimitation and splitting the rows is not working well. Because the string is too long!
            ## This is because of a 255 character limit per column
            <#
            $result = New-Object PSObject
            $result | Add-Member -MemberType NoteProperty -name ID -Value $findings_count.ToString() -ErrorAction SilentlyContinue
            $result | Add-Member -MemberType NoteProperty -name FindingName -Value $finding.FindingName -ErrorAction SilentlyContinue
            $result | Add-Member -MemberType NoteProperty -name ProductFamily -Value $finding.ProductFamily -ErrorAction SilentlyContinue
            $result | Add-Member -MemberType NoteProperty -name Impact -Value $finding.Impact -ErrorAction SilentlyContinue
            $result | Add-Member -MemberType NoteProperty -name CVS -Value $finding.CVS.ToString() -ErrorAction SilentlyContinue
            #$result | Add-Member -MemberType NoteProperty -name Finding -Value $finding.Description -ErrorAction SilentlyContinue
            $result | Add-Member -MemberType NoteProperty -name DefaultValue -Value $finding.DefaultValue -ErrorAction SilentlyContinue
            $result | Add-Member -MemberType NoteProperty -name ExpectedValue -Value $finding.ExpectedValue -ErrorAction SilentlyContinue
            #$result | Add-Member -MemberType NoteProperty -name AffectedObjects -Value $("$($finding.AffectedObjects)" | Out-String).Trim() -ErrorAction SilentlyContinue
            #$result | Add-Member -MemberType NoteProperty -name Remediation -Value $finding.Remediation -ErrorAction SilentlyContinue
            #$result | Add-Member -MemberType NoteProperty -name References -Value $($refs | Out-String)  -ErrorAction SilentlyContinue
            $results += $result
            #>
        }
    }

$filename = "$out_path\Report_$(Get-Date -Format "yyyy-MM-dd_hh-mm-ss")_$org_name.csv"
$results | Export-Csv $filename -NoTypeInformation -Append -Force
return $filename
}
Elseif ($reportType -eq "XML"){
    $sortedFindings = $findings | Sort-Object {$_.CVS} -Descending
    #$sortedFindings = $findings | Sort-Object {Switch -Regex ($_.Impact){'Critical' {1}	'High' {2}	'Medium' {3}	'Low' {4}	'Informational' {5}};$_.FindingName}

    $results = @()

    $findings_count = 0

    foreach ($finding in $sortedFindings){
        If ($null -NE $finding.AffectedObjects) {
            $findings_count += 1

            $refs = @()

            foreach ($ref in $finding.References){
                $refs += "$($ref.Text) : $($ref.Url)"
            }

            $executeinspectorsobject = New-Object PSObject -Property @{
              Findings = $findings
              StartDate = $startdate
              Inspectors = $selected_inspectors
              }

            $result = New-Object PSObject -ErrorAction SilentlyContinue -Property @{
             ID = $findings_count.ToString()
             FindingName = $finding.FindingName
             ProductFamily = $finding.ProductFamily
             Impact = $finding.Impact
             CVS = $finding.CVS.ToString()
             DefaultValue = $finding.DefaultValue
             ExpectedValue = $finding.ExpectedValue
            }
            $results += $result
            <#
            $result = New-Object PSObject
            $result | Add-Member -MemberType NoteProperty -name ID -Value $findings_count.ToString() -ErrorAction SilentlyContinue
            $result | Add-Member -MemberType NoteProperty -name FindingName -Value $finding.FindingName -ErrorAction SilentlyContinue
            $result | Add-Member -MemberType NoteProperty -name ProductFamily -Value $finding.ProductFamily -ErrorAction SilentlyContinue
            $result | Add-Member -MemberType NoteProperty -name Impact -Value $finding.Impact -ErrorAction SilentlyContinue
            $result | Add-Member -MemberType NoteProperty -name CVS -Value $finding.CVS.ToString() -ErrorAction SilentlyContinue
            #$result | Add-Member -MemberType NoteProperty -name Finding -Value $finding.Description -ErrorAction SilentlyContinue
            $result | Add-Member -MemberType NoteProperty -name DefaultValue -Value $finding.DefaultValue -ErrorAction SilentlyContinue
            $result | Add-Member -MemberType NoteProperty -name ExpectedValue -Value $finding.ExpectedValue -ErrorAction SilentlyContinue
            #$result | Add-Member -MemberType NoteProperty -name AffectedObjects -Value $("$($finding.AffectedObjects)" | Out-String).Trim() -ErrorAction SilentlyContinue
            #$result | Add-Member -MemberType NoteProperty -name Remediation -Value $finding.Remediation -ErrorAction SilentlyContinue
            #$result | Add-Member -MemberType NoteProperty -name References -Value $($refs | Out-String)  -ErrorAction SilentlyContinue
            $results += $result
            #>
        }
    }
$filename = "$out_path\Report_$(Get-Date -Format "yyyy-MM-dd_hh-mm-ss")_$org_name.xml"
$results | Export-Clixml -Depth 3 -Path $filename
return $filename
}
}

function Parse-Template {
  try {
    $template = (Get-Content "$PSScriptRoot\365InspectDefaultTemplate.html") -join "`n"
    $template -match '\<!--BEGIN_FINDING_LONG_REPEATER-->([\s\S]*)\<!--END_FINDING_LONG_REPEATER-->'
    $findings_long_template = $matches[1]

    $template -match '\<!--BEGIN_FINDING_SHORT_REPEATER-->([\s\S]*)\<!--END_FINDING_SHORT_REPEATER-->'
    $findings_short_template = $matches[1]

    $template -match '\<!--BEGIN_AFFECTED_OBJECTS_REPEATER-->([\s\S]*)\<!--END_AFFECTED_OBJECTS_REPEATER-->'
    $affected_objects_template = $matches[1]

    $template -match '\<!--BEGIN_REFERENCES_REPEATER-->([\s\S]*)\<!--END_REFERENCES_REPEATER-->'
    $references_template = $matches[1]

    $template -match '\<!--BEGIN_EXECSUM_TEMPLATE-->([\s\S]*)\<!--END_EXECSUM_TEMPLATE-->'
    $execsum_template = $matches[1]

    return @{
      FindingShortTemplate = $findings_short_template;
      FindingLongTemplate = $findings_long_template;
      AffectedObjectsTemplate = $affected_objects_template;
      ReportTemplate = $template;
      ReferencesTemplate = $references_template;
      ExecsumTemplate = $execsum_template
    }
  }
  catch {
    Exception
  }
}

function CreateDirectory(){
  #Create Output Directory if required
  if (Test-Path -Path $out_path){
  Write-Host "Path Exists! Checking Permissions..."
  try{
  $newpath = "$out_path\$($org_name)_$(Get-Date -Format "yyyyMMddhhmmss")"
  New-Item -ItemType Directory -Force -Path $newpath | Out-Null
  $path = Resolve-Path $out_path
  return $newpath
  }catch{
  Write-Error "Could not create directory" 
  break
  }
  }else{
  Write-Host "Path does not exist! Creating Directory..."
  try{
  New-Item -ItemType Directory -Force -Path $out_path | Out-Null
  $newpath = "$out_path\$($org_name)_$(Get-Date -Format "yyyyMMddhhmmss")"
  New-Item -ItemType Directory -Force -Path $newpath | Out-Null
  $path = Resolve-Path $out_path
  return $newpath
  }catch{
  Write-Error "Could not create Directory! Insufficient Permissions!"
  break
  }
  }
}

function SaveFile() {
  try {
    $compress = @{
      Path = $out_path
      CompressionLevel = "Fastest"
      DestinationPath = "$out_path\$($org_name)_Report_$(Get-Date -Format "yyyy-MM-dd_hh-mm-ss").zip"
    }
    Compress-Archive @compress
  }
  catch {
    'File Already Exists!'
  }
}

function DisconnectServices {
  Write-Output "Disconnecting from Microsoft Teams..."
  Disconnect-MicrosoftTeams
    Write-Output "Disconnecting from Azure Powershell..."
  Disconnect-AzAccount | Out-Null
  Write-Output "Disconnecting from MSOnline Service..."
  [Microsoft.Online.Administration.Automation.ConnectMsolService]::ClearUserSessionState()
  Write-Output "Disconnecting from Azure Active Directory..."
  Disconnect-AzureAD
  Write-Output "Disconnecting from Exchange Online & IPPSSession..."
  Disconnect-ExchangeOnline -Confirm:$false
  Write-Output "Disconnecting from SharePoint Service..."
  Disconnect-SPOService
  Write-Output "Disconnecting from Microsoft Intune & Microsoft Graph..."
  Disconnect-MgGraph | Out-Null
  Write-Output "Disconnecting from Microsoft Powershell PnP..."
  Disconnect-PnPOnline
}

#Fun Banners To Make The Program Awesome!
function Banner {
  $banner1 = @"

-------- -------- -------- --------  ----    ---- ------------ -----------  ------------ ------------ ------------
******** ******** ******** ********  *****   **** ************ ************ ************ ************ ************     ****
     --- ---      ---        ----    ------  ---- ----         ---      --- ----         ---          ------------     ----
******** ***      ********   ****    ************ ************ ************ ************ ***              ****     ************
-------- -------- --------   ----    ------------ ------------ -----------  ------------ ---              ----     ------------
     *** ***  ***      ***   ****    ****   *****         **** ****         ***          ***              ****         ****
-------- ---  --- -------- --------  ----    ---- ------------ ----         ------------ ------------     ----         ----
******** ******** ******** ********  ****    **** ************ ****         ************ ************     ****                                                                    
365Inspect - The M365 Environment Audit Tool - Version 0.1.0 Beta - Leonardo van de Weteringh
"@
  $banner2 = @"
........................................................................................
.######....##....######..######..##..##...####...#####...######...####...######....##...
....##....##.....##........##....###.##..##......##..##..##......##..##....##......##...
...###...#####....####.....##....##.###...####...#####...####....##........##....######.
.....##..##..##......##....##....##..##......##..##......##......##..##....##......##...
.#####....####...#####...######..##..##...####...##......######...####.....##......##...
........................................................................................ 
365Inspect - The M365 Environment Audit Tool - Version 0.1.0 Beta - Leonardo van de Weteringh                    
"@

  $banner3 = @"

 ::::::::   ::::::::  :::::::::: ::::::::::: ::::    :::  ::::::::  :::::::::  :::::::::: :::::::: :::::::::::    
:+:    :+: :+:    :+: :+:    :+:     :+:     :+:+:   :+: :+:    :+: :+:    :+: :+:       :+:    :+:    :+:        :::
       +:+ +:+        +:+            +:+     :+:+:+  +:+ +:+        +:+    +:+ +:+       +:+           +:+        :+:
    +#++:  +#++:++#+  +#++:++#+      +#+     +#+ +:+ +#+ +#++:++#++ +#++:++#+  +#++:++#  +#+           +#+     #:#+:+#:#
       +#+ +#+    +#+        +#+     +#+     +#+  +#+#+#        +#+ +#+        +#+       +#+           +#+     #:#+#+#:#
#+#    #+# #+#    #+# #+#    #+#     #+#     #+#   #+#+# #+#    #+# #+#        #+#       #+#    #+#    #+#        #+#
 ########   ########   ########  ########### ###    ####  ########  ###        ########## ########     ###        ###
365Inspect - The M365 Environment Audit Tool - Version 0.1.0 Beta - Leonardo van de Weteringh                  
"@

  $banner4 = @"
  _______ _______ _______ ___                              __     __   
 |   _   |   _   |   _   |   .-----.-----.-----.-----.----|  |_ _|  |_ 
 |___|   |   1___|   1___|.  |     |__ --|  _  |  -__|  __|   _|_    _|
  _(__   |.     \|____   |.  |__|__|_____|   __|_____|____|____| |__|  
 |:  1   |:  1   |:  1   |:  |           |__|                          
 |::.. . |::.. . |::.. . |::.|                                         
 `-------`-------`-------`---'                                         
365Inspect - The M365 Environment Audit Tool - Version 0.1.0 Beta - Leonardo van de Weteringh
"@

  $banner5 = @"                                                 
@@@@@@     @@@@@@  @@@@@@@  @@@  @@@  @@@   @@@@@@   @@@@@@@   @@@@@@@@   @@@@@@@  @@@@@@@             
@@@@@@@   @@@@@@@  @@@@@@@  @@@  @@@@ @@@  @@@@@@@   @@@@@@@@  @@@@@@@@  @@@@@@@@  @@@@@@@             
    @@@  !@@       !@@      @@!  @@!@!@@@  !@@       @@!  @@@  @@!       !@@         @@!       @@@     
    @!@  !@!       !@!      !@!  !@!!@!@!  !@!       !@!  @!@  !@!       !@!         !@!       !@!     
@!@!!@   !!@@!@!   !!@@!!   !!@  @!@ !!@!  !!@@!!    @!@@!@!   @!!!:!    !@!         @!!    @!@!@!@!@  
!!@!@!   @!!@!!!!  @!!@!!!  !!!  !@!  !!!   !!@!!!   !!@!!!    !!!!!:    !!!         !!!    !!!@!@!!!  
    !!:  !:!  !:!      !:!  !!:  !!:  !!!       !:!  !!:       !!:       :!!         !!:       :!:     
    :!:  :!:  !:!      !:!  :!:  :!:  !:!      !:!   :!:       :!:       :!:         :!:       :::     
:: ::::  :::: :::  :::: ::   ::   ::   ::  :::: ::    ::        :: ::::   ::: :::     ::        :       
 : : :    :: : :   :: : :   :    ::    :   :: : :     :        : :: ::    :: :: :     :                 
365Inspect - The M365 Environment Audit Tool - Version 0.1.0 Beta - Leonardo van de Weteringh
"@
  $banner = @($banner1,$banner2,$banner3,$banner4,$banner5)
  $bannernumber = (Get-Random -Maximum $banner.length)
  Write-Host ($banner[$bannernumber]) -ForegroundColor Yellow
}

function Main {
  Banner
  CheckAdminPrivBeta #First Checking Admin
  CheckInstalledModules #Check Install Modules + Updates + Uninstall only earlier versions
  Connect-Services #Connect to Services!
  $out_path = CreateDirectory #Creates a directory
  $findings = ExecuteInspectors #Executes the inspectors
  $report = GenerateReport($findings) #Processes the findings into the report
  SaveFile #Created a .zip file with all the findings and the report
  DisconnectServices #Disconnects services afterwards
  Write-Host "Report Generated! Opening..."
  Invoke-Item $report #Opens the report after the audit is successfully executed!
}
Main
return

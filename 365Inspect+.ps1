<#
Author: Soteria-Se, Leonardo van de Weteringh
Copright: 2022
Version: 0.0.5beta+
Usage: ./365Inspect.ps1 or ./365Inspect.exe
Date: 23-06-2022
#>

<#
  .SYNOPSIS
  Performs an Microsoft 365 Security Assessment.

  .DESCRIPTION
  Automate the security assessment of Microsoft 365 environments.

  .PARAMETER OrgName
  The name of the core organization or "company" of your M365 instance, which will be inspected.
  e.g. yourcompany

  .PARAMETER OutPath
  The path to a folder where the report generated by 365Inspect will be placed.
  e.g. C:\output

  .PARAMETER MFA
  A switch that would check if MFA needs to be used for authentication

  .PARAMETER Username
  Username of O365 account.
  e.g. example@yourcompany.com

  .PARAMETER Password (NOT YET IMPLEMENTED)
  Password of O365 account.

  .PARAMETER SkipUpdateCheck
  Skips Update Checking and Installing of Programs

  .INPUTS
  None. You cannot pipe objects to 365Inspect.ps1.

  .OUTPUTS
  None. 365Inspect.ps1 does not generate any output.

  .EXAMPLE
  PS> .\365Inspect.ps1
#>

param(
  [Parameter(Mandatory = $true,
    HelpMessage = 'Organization name')]
  [string]$OrgName,
  [Parameter(Mandatory = $true,
    HelpMessage = 'Output path for report')]
  [string]$OutPath,
  [Parameter(Mandatory = $false,
    HelpMessage = 'Username')]
  [string]$Username,
  [Parameter(Mandatory = $false,
    HelpMessage = 'Password')]
  [string]$Password,
  [Parameter(Mandatory = $false,
    HelpMessage = 'Skip Update Check')]
  [switch]$SkipUpdateCheck,
  [Parameter(Mandatory = $false,
    HelpMessage = 'Auth Type')]
  [switch]$MFA,
  [string[]]$SelectedInspectors = @(),
  [string[]]$ExcludedInspectors = @()
)

$user_name = $Username
$pass_word = $Password
$org_name = $OrgName
$out_path = $OutPath
$selected_inspectors = $SelectedInspectors
$excluded_inspectors = $ExcludedInspectors
$ConnectedServices = ""


function CheckAdminPrivBeta {
  # Check if script is running as Adminstrator and if not use RunAs
  Write-Host "[...] Checking if the script is running as Administrator"
  $IsAdmin = ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]"Administrator")
  if (-not $IsAdmin) {
    Write-Host "[!] The script is NOT running as Administrator, restarting PowerShell as Administrator..." -ForegroundColor Red
    try {
      $cmd = $PSCommandPath + " -OrgName $OrgName -OutPath $OutPath"
      if (-not [string]::IsNullOrEmpty($user_name)) {
        $cmd = $cmd + " -username " + $Username
      }
      if (-not [string]::IsNullOrEmpty($pass_word)) {
        $cmd = $cmd + " -password " + $Password
      }
      if ($SkipUpdateCheck.IsPresent) {
        $cmd = $cmd + " -SkipUpdateCheck"
      }
      if ($MFA.IsPresent) {
        $cmd = $cmd + " -MFA"
      }
      $arguments = "-NoProfile -NoExit -Command ""& {$cmd} """
      Start-Process "$psHome\powershell.exe" -Verb Runas -ArgumentList $arguments -ErrorAction Stop
      break
    } catch {
      Write-Warning "[!] Program needs Administrator Rights! You cannot run this in normal user mode!"
      break
    }
  }
  else {
    Write-Host "[+] The script is running as Administrator..." -ForegroundColor Green
  }
}


function CheckInstalledModules {
  if (-not $SkipUpdateCheck.IsPresent) {
    Write-Warning "[?] Checking Installed Modules..."
    # Define the set of modules installed and updated from the PowerShell Gallery that we want to maintain
    $O365Modules = @("MicrosoftTeams","MSOnline","AzureADPreview","Az","ExchangeOnlineManagement","Microsoft.Online.Sharepoint.PowerShell","Microsoft.Graph","Microsoft.Graph.Intune")
    #Check which Modules are Installed Already...
    $installed = Get-InstalledModule
    foreach ($module in $O365Modules) {
      if ($installed.Name -notcontains $module) {
        Write-Host "`n$module is not installed." -ForegroundColor Red
        Write-Warning 'The module may be installed by running "Install-Module $module -Force -Scope CurrentUser -Confirm:$false" in an elevated PowerShell window.'
        $install = Read-Host -Prompt "Would you like to attempt installation now? (Y|N)"
        if ($install -eq 'y') {
          Install-Module $module -Scope CurrentUser -Force -Confirm:$false
          $count++
        }
      } else {
        Write-Host "[+] $module is installed." -ForegroundColor Green
        $count++
      }
    }
    Write-Host "[?] Checking Installed Modules Updates..." -ForegroundColor Yellow
    foreach ($module in $O365Modules) {
      $onversion = Find-Module -Name $module -ErrorAction Stop -AllowPrerelease
      $localversion = Get-InstalledModule -Name $module -ErrorAction Stop
      #compare versions
      if ($localversion.Version -ilt $onversion.Version -or $localversion.Version -ne $onversion.Version) {
        Write-Warning ($onversion.Version + ' != ' + $localversion.Version)
        Write-Host "Trying to update $module ..."
        Update-Module -Name $module -AllowPrerelease -Force
      }
      if ($onversion.Version -ige $localversion.Version) {
        Write-Warning ($module + ' is up-to-date!')
      }
    }
    #Check if PowerShellGet is on Version 3 instead of 2
    $PowerShellGetVersion = Get-InstalledModule -Name "PowerShellGet" -ErrorAction Stop
    if ($PowerShellGetVersion.Version -igt 2.2.5) {
      foreach ($module in $O365Modules) {
        Write-Host "[?] Checking for older versions of" $module
        $AllVersions = Get-InstalledModule -Name $module -AllVersions -AllowPrerelease | Measure-Object
        if ($AllVersions.Count -igt 1)
        {
          $AllVersions = Get-InstalledModule -Name $module -AllVersions -AllowPrerelease | Sort Version
          $MostRecentVersion = $AllVersions[0].Version
          Write-Host "Most recent version of" $module "is" $MostRecentVersion
          foreach ($Version in $AllVersions) { #Check each version and remove old versions
            if ($Version.Version -ilt $MostRecentVersion -or $Version.Version -ne $MostRecentVersion) { # Old version - remove
              Write-Host "Uninstalling version" $Version.Version "of Module" $module "..." -ForegroundColor Red
              Uninstall-PSResource -Name $module -Version $Version.Version
            }
          }
        }
      }
    } else {
      # Check and remove older versions of the modules from the PC (Classic Method)
      foreach ($module in $O365Modules) {
        Write-Host "[?] Checking for older versions of" $module
        $AllVersions = Get-InstalledModule -Name $module -AllVersions -AllowPrerelease | Measure-Object
        if ($AllVersions.Count -igt 1) {
          $AllVersions = Get-InstalledModule -Name $module -AllVersions -AllowPrerelease | Sort Version -Descending
          $MostRecentVersion = $AllVersions[0].Version
          Write-Host "Most recent version of" $module "is" $MostRecentVersion
          foreach ($Version in $AllVersions) { #Check each version and remove old versions
            if ($Version.Version -ilt $MostRecentVersion) { # Old version - remove
              Write-Host "Uninstalling version" $Version.Version "of Module" $module "..." -ForegroundColor Red
              Uninstall-Module -Name $module -RequiredVersion $Version.Version -Force
            } #End if
          } #End ForEach
        } #End If
      } #End ForEach
    }
    #END SCRIPT
  }
}

function Exception {
  if (-not (Get-Variable -Name 'PSScriptRoot' -Scope 'Script')) {
    $Script:PSScriptRoot = Split-Path -Path $MyInvocation.MyCommand.Definition -Parent
  }
  if ($psISE) {
    .(Join-Path (Split-Path -Path $psISE.CurrentFile.FullPath) Write-ErrorLog.ps1)
  } else {
    .(Join-Path $PSScriptRoot Write-ErrorLog.ps1)
  }
  Write-Warning "Error message: $_"
  $message = $_.ToString()
  $exception = $_.Exception
  $strace = $_.ScriptStackTrace
  $failingline = $_.InvocationInfo.Line
  $positionmsg = $_.InvocationInfo.PositionMessage
  $pscommandpath = $_.InvocationInfo.PSCommandPath
  $failinglinenumber = $_.InvocationInfo.ScriptLineNumber
  $scriptname = $_.InvocationInfo.ScriptName
  Write-Verbose "Write to log"
  Write-ErrorLog -Message $message -Exception $exception -scriptname $scriptname -failinglinenumber $failinglinenumber -failingline $failingline -pscommandpath $pscommandpath -positionmsg $pscommandpath -stacktrace $strace
  Write-Verbose "Errors written to log"
}

function Connect-Services {
  if ($MFA.IsPresent) {
    #Microsoft Teams
    try {
      Write-Output "Connecting to Microsoft Teams"
      if (-not [string]::IsNullOrEmpty($Username)) {
        $Team = Connect-MicrosoftTeams -AccountId $Username
      } else {
        $Team = Connect-MicrosoftTeams
      }
      if (-not [string]::IsNullOrEmpty($Team)) {
        Write-Warning "Succesfully Connected to Microsoft Teams"
        $ConnectedServices = $ConnectedServices + "Microsoft Teams `n"
      }
    } catch {
      Exception
      break
    }

    #Azure PowerShell (in progress)
    try{
    Write-Output "Connecting to Azure PowerShell..."
    if (-not [string]::IsNullOrEmpty($Username)) {
    Connect-AzAccount -AccountId $Username -ErrorAction Stop | Out-Null
    }else{
    Connect-AzAccount -ErrorAction Stop | Out-Null
    }
    if (Get-AzAccessToken)
    {
    Write-Warning "Succesfully Connected to Azure PowerShell"
    }
    }catch{
        Exception
        break
    }

    #Microsoft Online Service
    try {
      Write-Output "Connecting to MSOnline Service..."
      Connect-MsolService -ErrorAction Stop
      if ((Get-MsolUser -MaxResults 1) -ne $null)
      {
        Write-Warning "Succesfully Connected to MSOnline"
        $ConnectedServices = $ConnectedServices + "MSOnline `n"
      }
    } catch {
      Exception
      break
    }

    #Azure-AD (Preview)
    try {
      Write-Output "Connecting to Azure Active Directory..."
      if (-not [string]::IsNullOrEmpty($Username)) {
        Connect-AzureAD -AccountId $Username -ErrorAction Stop | Out-Null
      } else {
        Connect-AzureAD -ErrorAction Stop | Out-Null
      }
      if ((Get-AzureADUser -Top 1) -ne $null) {
        Write-Warning "Succesfully Connected to AzureAD"
        $ConnectedServices = $ConnectedServices + "AzureAD `n"
      }
    } catch {
      Exception
      break
    }

    #Exchange Online
    try {
      Write-Output "Connecting to Exchange Online..."
      if (-not [string]::IsNullOrEmpty($Username)) {
        Connect-ExchangeOnline -UserPrincipalName $Username -ShowBanner:$false -ErrorAction Stop
      } else {
        Connect-ExchangeOnline -ShowBanner:$false -ErrorAction Stop
      }
      if ((Get-EXOMailbox -ResultSize 1) -ne $null) {
        Write-Warning "Succesfully Connected to Exchange Online"
        $ConnectedServices = $ConnectedServices + "Exchange Online `n"
      }
    } catch {
      Exception
      break
    }

    #Sharepoint Service
    try {
      Write-Output "Connecting to SharePoint Service"
      Import-Module Microsoft.Online.SharePoint.PowerShell -DisableNameChecking
      Connect-SPOService -ErrorAction Stop -Url "https://$org_name-admin.sharepoint.com"
      if ((Get-SPOTenant) -ne $null) {
        Write-Warning "Succesfully Connected to SharePoint Online"
        $ConnectedServices = $ConnectedServices + "SharePoint Online `n"
      }
    } catch {
      Exception
      break
    }

    #Microsoft InTune
    try {
      Write-Output "Connecting and consenting to Microsoft Intune"
      Connect-MSGraph -AdminConsent -ErrorAction Stop | Out-Null
      if ((Get-IntuneManagedDevice -Top 1) -ne $null) {
        Write-Warning "Succesfully Connected to Microsoft InTune"
        $ConnectedServices = $ConnectedServices + "Microsoft InTune `n"
      }
    } catch {
      Exception
      break
    }

    #Microsoft Graph
    try {
      Write-Output "Connecting and consenting to Microsoft Graph"
      $MSGraph = Connect-MgGraph -ErrorAction Stop -Scopes "AuditLog.Read.All","Policy.Read.All","Directory.Read.All","IdentityProvider.Read.All","Organization.Read.All","Securityevents.Read.All","ThreatIndicators.Read.All","SecurityActions.Read.All","User.Read.All","UserAuthenticationMethod.Read.All","MailboxSettings.Read"
      if ($MSGraph -contains "Welcome To Microsoft Graph!") {
        Write-Warning "Succesfully Connected to Microsoft Graph"
        $ConnectedServices = $ConnectedServices + "Microsoft Graph `n"
      }
    } catch {
      Exception
      break
    }

    #Security & Compliance Center IPPSSession
    try {
      Write-Output "Connecting to IPPSSession..."
      if (-not [string]::IsNullOrEmpty($Username)) {
        Connect-IPPSSession -UserPrincipalName $Username -WarningAction SilentlyContinue -ErrorAction Stop
      } else {
        Connect-IPPSSession -WarningAction SilentlyContinue -ErrorAction Stop
      }
      $Result = Get-RetentionCompliancePolicy
      if (($?) -eq $true) {
        Write-Warning "Succesfully Connected to Security & Compliance Center"
        $ConnectedServices = $ConnectedServices + "IPPSSession `n"
      }
    } catch {
      Exception
      break
    }
  } elseif (-not [string]::IsNullOrEmpty($Username) -and -not [string]::IsNullOrEmpty($Password)) {
    #DO NORMAL AUTHENTICATION HERE with Username and Password
    try {
      $SecuredPassword = ConvertTo-SecureString -AsPlainText $Password -Force
      $Credential = New-Object System.Management.Automation.PSCredential $UserName,$SecuredPassword
    } catch {
      Exception
    }

    #Microsoft Teams
    try {
      Write-Output "Connecting to Microsoft Teams"
      $Team = Connect-MicrosoftTeams -Credential $Credential -ErrorAction Stop
      if (-not [string]::IsNullOrEmpty($Team)) {
        Write-Warning "Succesfully Connected to Microsoft Teams"
        $ConnectedServices = $ConnectedServices + "Microsoft Teams `n"
      }
    } catch {
      Exception
      break
    }

        #Azure PowerShell (in progress)
    try{
    Write-Output "Connecting to Azure PowerShell..."
    Connect-AzAccount -Credential $Credential -ErrorAction Stop | Out-Null
    if (Get-AzAccessToken)
    {
    Write-Warning "Succesfully Connected to Azure PowerShell"
    }
    }catch{
        Exception
        break
    }

    #Microsoft Online Service
    try {
      Write-Output "Connecting to MSOnline Service..."
      Connect-MsolService -Credential $Credential -ErrorAction Stop
      if ((Get-MsolUser -MaxResults 1) -ne $null)
      {
        Write-Warning "Succesfully Connected to MSOnline"
        $ConnectedServices = $ConnectedServices + "MSOnline `n"
      }
    } catch {
      Exception
      break
    }
    #Azure-AD (Preview)
    try {
      Write-Output "Connecting to Azure Active Directory..."
      Connect-AzureAD -Credential $Credential -ErrorAction Stop | Out-Null
      if ((Get-AzureADUser -Top 1) -ne $null) {
        Write-Warning "Succesfully Connected to AzureAD"
        $ConnectedServices = $ConnectedServices + "AzureAD `n"
      }
    } catch {
      Exception
      break
    }
    #Exchange Online
    try {
      Write-Output "Connecting to Exchange Online..."
      Connect-ExchangeOnline -Credential $Credential -ShowBanner:$false -ErrorAction Stop
      if ((Get-EXOMailbox -ResultSize 1) -ne $null) {
        Write-Warning "Succesfully Connected to Exchange Online"
        $ConnectedServices = $ConnectedServices + "Exchange Online `n"
      }
    } catch {
      Exception
      break
    }
    #Sharepoint Service
    try {
      Write-Output "Connecting to SharePoint Service"
      Import-Module Microsoft.Online.SharePoint.PowerShell -DisableNameChecking
      Connect-SPOService -Url "https://$org_name-admin.sharepoint.com" -Credential $Credential -ErrorAction Stop
      if ((Get-SPOTenant) -ne $null) {
        Write-Warning "Succesfully Connected to SharePoint Online"
        $ConnectedServices = $ConnectedServices + "SharePoint Online `n"
      }
    } catch {
      Exception
      break
    }

    #Microsoft InTune
    try {
      Write-Output "Connecting and consenting to Microsoft Intune"
      Connect-MSGraph -AdminConsent -ErrorAction Stop | Out-Null
      Connect-MSGraph -ErrorAction Stop | Out-Null
      if ((Get-IntuneManagedDevice -Top 1) -ne $null) {
        Write-Warning "Succesfully Connected to Microsoft InTune"
        $ConnectedServices = $ConnectedServices + "Microsoft InTune `n"
      }
    } catch {
      Exception
      break
    }

    #Microsoft Graph

    try {
      Write-Output "Connecting and consenting to Microsoft Graph"
      $MSGraph = Connect-MgGraph -ErrorAction Stop -Scopes "AuditLog.Read.All","Policy.Read.All","Directory.Read.All","IdentityProvider.Read.All","Organization.Read.All","Securityevents.Read.All","ThreatIndicators.Read.All","SecurityActions.Read.All","User.Read.All","UserAuthenticationMethod.Read.All","MailboxSettings.Read"
      if ($MSGraph -contains "Welcome To Microsoft Graph!") {
        Write-Warning "Succesfully Connected to Microsoft Graph"
        $ConnectedServices = $ConnectedServices + "Microsoft Graph `n"
      }
    } catch {
      Exception
      break
    }

    #Security & Compliance Center IPPSSession
    try {
      Write-Output "Connecting to IPPSSession..."
      Connect-IPPSSession -Credential $Credential -WarningAction SilentlyContinue -ErrorAction Stop
      $Result = Get-RetentionCompliancePolicy
      if (($?) -eq $true) {
        Write-Warning "Succesfully Connected to Security & Compliance Center"
        $ConnectedServices = $ConnectedServices + "IPPSSession `n"
      }
    } catch {
      Exception
      break
    }
  } else {
    #Normal Auth

    #Microsoft Teams
    #There is a bug that if we put Microsoft Teams somewhere in the middle to connect that we might get an exception.
    try {
      Write-Output "Connecting to Microsoft Teams"
      if (-not [string]::IsNullOrEmpty($Username)) {
        $Team = Connect-MicrosoftTeams -AccountId $Username
      } else {
        $Team = Connect-MicrosoftTeams
      }
      if (-not [string]::IsNullOrEmpty($Team)) {
        Write-Warning "Succesfully Connected to Microsoft Teams"
        $ConnectedServices = $ConnectedServices + "Microsoft Teams `n"
      }
    } catch {
      Exception
      break
    }

            #Azure PowerShell (in progress)
    try{
    Write-Output "Connecting to Azure PowerShell..."
    if (-not [string]::IsNullOrEmpty($Username)) {
        Connect-AzAccount -AccountId $Username | Out-Null
      } else {
        Connect-AzAccount | Out-Null
      }
    if (Get-AzAccessToken)
    {
    Write-Warning "Succesfully Connected to Azure PowerShell"
    }
    }catch{
        Exception
        break
    }

    #Microsoft Online Service
    try {
      Write-Output "Connecting to MSOnline Service..."
      Connect-MsolService -ErrorAction Stop
      if ((Get-MsolUser -MaxResults 1) -ne $null)
      {
        Write-Warning "Succesfully Connected to MSOnline"
        $ConnectedServices = $ConnectedServices + "MSOnline `n"
      }
    } catch {
      Exception
      break
    }
    #Azure-AD (Preview)
    try {
      Write-Output "Connecting to Azure Active Directory..."
      if (-not [string]::IsNullOrEmpty($Username)) {
        Connect-AzureAD -ErrorAction Stop -AccountId $Username | Out-Null
      } else {
        Connect-AzureAD -ErrorAction Stop | Out-Null
      }
      if ((Get-AzureADUser -Top 1) -ne $null) {
        Write-Warning "Succesfully Connected to AzureAD"
        $ConnectedServices = $ConnectedServices + "AzureAD `n"
      }
    } catch {
      Exception
      break
    }
    #Exchange Online
    try {
      Write-Output "Connecting to Exchange Online..."
      if (-not [string]::IsNullOrEmpty($Username)) {
        Connect-ExchangeOnline -UserPrincipalName $Username -ShowBanner:$false
      } else {
        Connect-ExchangeOnline -ShowBanner:$false
      }
      if ((Get-EXOMailbox -ResultSize 1) -ne $null) {
        Write-Warning "Succesfully Connected to Exchange Online"
        $ConnectedServices = $ConnectedServices + "Exchange Online `n"
      }
    } catch {
      Exception
      break
    }
    #Sharepoint Service
    try {
      Write-Output "Connecting to SharePoint Service"
      Import-Module Microsoft.Online.SharePoint.PowerShell -DisableNameChecking
      Connect-SPOService -Url "https://$org_name-admin.sharepoint.com" -ErrorAction Stop
      if ((Get-SPOTenant) -ne $null) {
        Write-Warning "Succesfully Connected to SharePoint Online"
        $ConnectedServices = $ConnectedServices + "SharePoint Online `n"
      }
    } catch {
      Exception
      break
    }

    #Microsoft InTune
    try {
      Write-Output "Connecting and consenting to Microsoft Intune"
      Connect-MSGraph -AdminConsent -ErrorAction Stop | Out-Null
      Connect-MSGraph -ErrorAction Stop | Out-Null
      if ((Get-IntuneManagedDevice -Top 1) -ne $null) {
        Write-Warning "Succesfully Connected to Microsoft InTune"
        $ConnectedServices = $ConnectedServices + "Microsoft InTune `n"
      }
    } catch {
      Exception
      break
    }

    #Microsoft Graph
    try {
      Write-Output "Connecting and consenting to Microsoft Graph"
      $MSGraph = Connect-MgGraph -ErrorAction Stop -Scopes "AuditLog.Read.All","Policy.Read.All","Directory.Read.All","IdentityProvider.Read.All","Organization.Read.All","Securityevents.Read.All","ThreatIndicators.Read.All","SecurityActions.Read.All","User.Read.All","UserAuthenticationMethod.Read.All","MailboxSettings.Read"
      if ($MSGraph -contains "Welcome To Microsoft Graph!") {
        Write-Warning "Succesfully Connected to Microsoft Graph"
        $ConnectedServices = $ConnectedServices + "Microsoft Graph `n"
      }
    } catch {
      Exception
      break
    }

    #Security & Compliance Center IPPSSession
    try {
      Write-Output "Connecting to IPPSSession..."
      if (-not [string]::IsNullOrEmpty($Username)) {
        Connect-IPPSSession -ErrorAction Stop -UserPrincipalName $Username -WarningAction SilentlyContinue
      } else {
        Connect-IPPSSession -ErrorAction Stop -WarningAction SilentlyContinue
      }
      $Result = Get-RetentionCompliancePolicy
      if (($?) -eq $true) {
        Write-Warning "Succesfully Connected to Security & Compliance Center"
        $ConnectedServices = $ConnectedServices + "IPPSSession `n"
      }
    } catch {
      Exception
      break
    }
    #Normal Authentication with just connecting to the session
  }
}

function ExecuteInspectors {
  # Get a list of every available detection module by parsing the PowerShell
  # scripts present in the .\inspectors folder. 
  #Exclude specified Inspectors
  if ($excluded_inspectors -and $excluded_inspectors.Count) {
    $excluded_inspectors = foreach ($inspector in $excluded_inspectors) { "$inspector.ps1" }
    $inspectors = (Get-ChildItem $PSScriptRoot\inspectors\*.ps1 -Exclude $excluded_inspectors).Name | ForEach-Object { ($_ -split ".ps1")[0] }
  }
  else {
    $inspectors = (Get-ChildItem $PSScriptRoot\inspectors\*.ps1).Name | ForEach-Object { ($_ -split ".ps1")[0] }
  }

  #Use Selected Inspectors
  if ($selected_inspectors -and $selected_inspectors.Count) {
    "The following inspectors were selected for use: "
    foreach ($inspector in $selected_inspectors) {
      Write-Output $inspector
    }
  }
  elseif ($excluded_Inspectors -and $excluded_inspectors.Count) {
    $selected_inspectors = $inspectors
    Write-Output "Using inspectors:`n"
    foreach ($inspector in $inspectors) {
      Write-Output $inspector
    }
  }
  else {
    "Using all inspectors."
    $selected_inspectors = $inspectors
  }

  #Create Output Directory if required
  try {
    New-Item -ItemType Directory -Force -Path $out_path | Out-Null
    if ((Test-Path $out_path) -eq $true) {
      $path = Resolve-Path $out_path
      Write-Output "$($path.Path) created successfully."
    }
  }
  catch {
    Write-Error "Directory not created. Please check permissions."
    break
  }

  # Maintain a list of all findings, beginning with an empty list.
  $findings = @()

  # For every inspector the user wanted to run...
  foreach ($selected_inspector in $selected_inspectors) {
    try {
      # ...if the user selected a valid inspector...
      if ($inspectors.Contains($selected_inspector)) {
        Write-Output "Invoking Inspector: $selected_inspector"

        # Get the static data (finding description, remediation etc.) associated with that inspector module.
        $finding = Get-Content $PSScriptRoot\inspectors\$selected_inspector.json | Out-String | ConvertFrom-Json

        # Invoke the actual inspector module and store the resulting list of insecure objects.
        $finding.AffectedObjects = Invoke-Expression "$PSScriptRoot\inspectors\$selected_inspector.ps1"

        # Add the finding to the list of all findings.
        $findings += $finding
      }
    }
    catch {
      Exception
    }
  }
$templates = Parse-Template

# Maintain a running list of each finding, represented as HTML
  $short_findings_html = '' 
  $long_findings_html = ''

  $findings_count = 0

  $critical_count = 0
  $high_count = 0
  $medium_count = 0
  $low_count = 0
  $informational_count = 0


#Sort Object on CVS Score
#$sortedFindings = $findings | Sort-Object {$_.CVS}
$sortedFindings = $findings | Sort-Object {Switch -Regex ($_.Impact){'Critical' {1}	'High' {2}	'Medium' {3}	'Low' {4}	'Informational' {5}};$_.FindingName} 
ForEach ($finding in $sortedFindings) {
	# If the result from the inspector was not $null,
	# it identified a real finding that we must process.
	If ($null -NE $finding.AffectedObjects) {
		# Increment total count of findings
		$findings_count += 1
		
		# Keep an HTML variable representing the current finding as HTML
		$short_finding_html = $templates.FindingShortTemplate
		$long_finding_html = $templates.FindingLongTemplate
		
		# Insert finding name and number into template HTML
		$short_finding_html = $short_finding_html.Replace("{{FINDING_NAME}}", $finding.FindingName)
		$short_finding_html = $short_finding_html.Replace("{{FINDING_NUMBER}}", $findings_count.ToString())
		$long_finding_html = $long_finding_html.Replace("{{FINDING_NAME}}", $finding.FindingName)
		$long_finding_html = $long_finding_html.Replace("{{FINDING_NUMBER}}", $findings_count.ToString())
		
		# Finding Impact
		$short_finding_html = $short_finding_html.Replace("{{IMPACT}}", $finding.Impact)
		$long_finding_html = $long_finding_html.Replace("{{IMPACT}}", $finding.Impact)


        # Statistics for user information
        if ($finding.Impact -like "*Critical*") {
          $long_finding_html = $long_finding_html.Replace("{{IMPACT_COLOR}}", "8b0000")
          $critical_count += 1
        } elseif ($finding.Impact -like "*High*") {
          $long_finding_html = $long_finding_html.Replace("{{IMPACT_COLOR}}", "ff0000")
          $high_count += 1
        } elseif ($finding.Impact -like "*Medium*") {
          $long_finding_html = $long_finding_html.Replace("{{IMPACT_COLOR}}", "f6be00")
          $medium_count += 1
        } elseif ($finding.Impact -like "*Low*") {
          $long_finding_html = $long_finding_html.Replace("{{IMPACT_COLOR}}", "008000")
          $low_count += 1
        } elseif ($finding.Impact -like "*Informational*") {
          $long_finding_html = $long_finding_html.Replace("{{IMPACT_COLOR}}", "0000ff")
          $informational_count += 1
        }
		
        # Finding CVS Score
        ##$short_finding_html = $short_finding_html.Replace("{{CVS}}",$finding.CVS.ToString())
        ##$long_finding_html = $long_finding_html.Replace("{{CVS}}",$finding.CVS.ToString())

        # Finding description
        $long_finding_html = $long_finding_html.Replace("{{DESCRIPTION}}",$finding.Description)

        # Finding default value
        $long_finding_html = $long_finding_html.Replace("{{DEFAULTVALUE}}",$finding.DefaultValue)

        # Finding expected value
        $long_finding_html = $long_finding_html.Replace("{{EXPECTEDVALUE}}",$finding.ExpectedValue)

        # Finding Residual risk
        ##$long_finding_html = $long_finding_html.Replace("{{RISKRATING}}",$finding.RiskRating)
				
		# Finding Remediation
		If ($finding.Remediation.length -GT 300) {
			$short_finding_text = "Complete remediation advice is provided in the body of the report. Clicking the link to the left will take you there."
		}
		Else {
			$short_finding_text = $finding.Remediation
		}
		
		$short_finding_html = $short_finding_html.Replace("{{REMEDIATION}}", $short_finding_text)
		$long_finding_html = $long_finding_html.Replace("{{REMEDIATION}}", $finding.Remediation)
		
		# Affected Objects
		If ($finding.AffectedObjects.Count -GT 15) {
			$condensed = "<a href='{name}'>{count} Affected Objects Identified<a/>."
			$condensed = $condensed.Replace("{count}", $finding.AffectedObjects.Count.ToString())
			$condensed = $condensed.Replace("{name}", $finding.FindingName)
			$affected_object_html = $templates.AffectedObjectsTemplate.Replace("{{AFFECTED_OBJECT}}", $condensed)
			$fname = $finding.FindingName
			$finding.AffectedObjects | Out-File -FilePath $out_path\$fname
		}
		Else {
			$affected_object_html = ''
			ForEach ($affected_object in $finding.AffectedObjects) {
				$affected_object_html += $templates.AffectedObjectsTemplate.Replace("{{AFFECTED_OBJECT}}", $affected_object)
			}
		}
		
		$long_finding_html = $long_finding_html.Replace($templates.AffectedObjectsTemplate, $affected_object_html)
		
		# References
		$reference_html = ''
		ForEach ($reference in $finding.References) {
			$this_reference = $templates.ReferencesTemplate.Replace("{{REFERENCE_URL}}", $reference.Url)
			$this_reference = $this_reference.Replace("{{REFERENCE_TEXT}}", $reference.Text)
			$reference_html += $this_reference
		}
		
		$long_finding_html = $long_finding_html.Replace($templates.ReferencesTemplate, $reference_html)
		
		# Add the completed short and long findings to the running list of findings (in HTML)
		$short_findings_html += $short_finding_html
		$long_findings_html += $long_finding_html
	}
}

# Insert command line execution information. This is coupled kinda badly, as is the Affected Objects html.
    $flags = "<b>Audited Organization:</b> <u>" + $org_name + "</u><br/><br/>"
    $flags = $flags + "<b>Audit Executed on:</b><i> "+ (Get-Date) + "</i><br/><br/>"
    $flags = $flags + "<b>Stats</b>:<br/> <b>" + $findings_count + "</b> out of <b>" + $inspectors.Count + "</b> executed inspector modules identified possible opportunities for improvement.<br/><br/>"  
    $flags = $flags + "<font color='#8b0000'><b>Critical</b></font>: <b><u>" + $critical_count + "</b></u><font color='red'><b> High</b></font>: <b><u>" + $high_count + "</b></u><font color='#f6be00'><b> Medium</b></font>: <b><u>" + $medium_count + "</b></u><font color='green'><b> Low</b></font>: <b><u>" + $low_count + "</b></u><font color='blue'><b> Informational</b></font>: <b><u>" + $informational_count + "</b></u><br/><br/>"
    $flags = $flags + "<b>Inspector Modules Executed</b>:<br/>" + [String]::Join("<br/>", $selected_inspectors)

$output = $templates.ReportTemplate.Replace($templates.FindingShortTemplate, $short_findings_html)
$output = $output.Replace($templates.FindingLongTemplate, $long_findings_html)
$output = $output.Replace($templates.ExecsumTemplate, $templates.ExecsumTemplate.Replace("{{CMDLINEFLAGS}}", $flags))

$output | Out-File -FilePath $out_path\Report_$(Get-Date -Format "yyyy-MM-dd_hh-mm-ss")_$org_name.html 
}

function Parse-Template {
  try {
    $template = (Get-Content "$PSScriptRoot\365InspectDefaultTemplate.html") -join "`n"
    $template -match '\<!--BEGIN_FINDING_LONG_REPEATER-->([\s\S]*)\<!--END_FINDING_LONG_REPEATER-->'
    $findings_long_template = $matches[1]

    $template -match '\<!--BEGIN_FINDING_SHORT_REPEATER-->([\s\S]*)\<!--END_FINDING_SHORT_REPEATER-->'
    $findings_short_template = $matches[1]

    $template -match '\<!--BEGIN_AFFECTED_OBJECTS_REPEATER-->([\s\S]*)\<!--END_AFFECTED_OBJECTS_REPEATER-->'
    $affected_objects_template = $matches[1]

    $template -match '\<!--BEGIN_REFERENCES_REPEATER-->([\s\S]*)\<!--END_REFERENCES_REPEATER-->'
    $references_template = $matches[1]

    $template -match '\<!--BEGIN_EXECSUM_TEMPLATE-->([\s\S]*)\<!--END_EXECSUM_TEMPLATE-->'
    $execsum_template = $matches[1]

    return @{
      FindingShortTemplate = $findings_short_template;
      FindingLongTemplate = $findings_long_template;
      AffectedObjectsTemplate = $affected_objects_template;
      ReportTemplate = $template;
      ReferencesTemplate = $references_template;
      ExecsumTemplate = $execsum_template
    }
  }
  catch {
    Exception
  }
}

function SaveFile {
  try {
    $compress = @{
      Path = $out_path
      CompressionLevel = "Fastest"
      DestinationPath = "$out_path\$($org_name)_Report_$(Get-Date -Format "yyyy-MM-dd_hh-mm-ss").zip"
    }
    Compress-Archive @compress
  }
  catch {
    'File Already Exists!'
  }
}

function DisconnectServices {
  Write-Output "Disconnecting from MSOnline Service..."
  [Microsoft.Online.Administration.Automation.ConnectMsolService]::ClearUserSessionState()
  Write-Output "Disconnecting from Azure Active Directory..."
  Disconnect-AzureAD
  Write-Output "Disconnecting from Exchange Online..."
  Disconnect-ExchangeOnline -Confirm:$false
  Write-Output "Disconnecting from SharePoint Service..."
  Disconnect-SPOService
  Write-Output "Disconnecting from Microsoft Teams..."
  Disconnect-MicrosoftTeams
  Write-Output "Disconnecting from Microsoft Intune & Microsoft Graph..."
  Disconnect-MgGraph
}

#Fun Banners To Make The Program Awesome!
function Banner {
  $banner1 = @"
 #####   #####  #######    #         ######   ##########    # #                                #     
#     # #     # #         ########            #        #    # #     ##########              #######  
      # #       #        #    #    ##########         #     # #             #    ##          # #     
 #####  ######  ######  #    #     #        #        #      # #   #        #    #  ##        # #     
      # #     #       #     #             ##        #      #  #  #      # #    #     ##   ########## 
#     # #     # #     #    #            ##        ##      #   # #        #             ##      #     
 #####   #####   #####    #           ##        ##       #    ##          #                    #    
365Inspect - The M365 Environment Audit Tool                    
Version 0.0.5+Beta - Leonardo van de Weteringh
"@
  $banner2 = @"

 ▄▄▄▄▄▄▄▄▄▄▄  ▄▄▄▄▄▄▄▄▄▄▄  ▄▄▄▄▄▄▄▄▄▄▄  ▄▄▄▄▄▄▄▄▄▄▄  ▄▄        ▄  ▄▄▄▄▄▄▄▄▄▄▄  ▄▄▄▄▄▄▄▄▄▄▄  ▄▄▄▄▄▄▄▄▄▄▄  ▄▄▄▄▄▄▄▄▄▄▄  ▄▄▄▄▄▄▄▄▄▄▄ 
▐░░░░░░░░░░░▌▐░░░░░░░░░░░▌▐░░░░░░░░░░░▌▐░░░░░░░░░░░▌▐░░▌      ▐░▌▐░░░░░░░░░░░▌▐░░░░░░░░░░░▌▐░░░░░░░░░░░▌▐░░░░░░░░░░░▌▐░░░░░░░░░░░▌
 ▀▀▀▀▀▀▀▀▀█░▌▐░█▀▀▀▀▀▀▀▀▀ ▐░█▀▀▀▀▀▀▀▀▀  ▀▀▀▀█░█▀▀▀▀ ▐░▌░▌     ▐░▌▐░█▀▀▀▀▀▀▀▀▀ ▐░█▀▀▀▀▀▀▀█░▌▐░█▀▀▀▀▀▀▀▀▀ ▐░█▀▀▀▀▀▀▀▀▀  ▀▀▀▀█░█▀▀▀▀ 
          ▐░▌▐░▌          ▐░█▄▄▄▄▄▄▄▄▄      ▐░▌     ▐░▌▐░▌    ▐░▌▐░▌          ▐░▌       ▐░▌▐░▌          ▐░▌               ▐░▌     
 ▄▄▄▄▄▄▄▄▄█░▌▐░█▄▄▄▄▄▄▄▄▄ ▐░░░░░░░░░░░▌     ▐░▌     ▐░▌ ▐░▌   ▐░▌▐░█▄▄▄▄▄▄▄▄▄ ▐░█▄▄▄▄▄▄▄█░▌▐░█▄▄▄▄▄▄▄▄▄ ▐░▌               ▐░▌     
▐░░░░░░░░░░░▌▐░░░░░░░░░░░▌ ▀▀▀▀▀▀▀▀▀█░▌     ▐░▌     ▐░▌  ▐░▌  ▐░▌▐░░░░░░░░░░░▌▐░░░░░░░░░░░▌▐░░░░░░░░░░░▌▐░▌               ▐░▌     
 ▀▀▀▀▀▀▀▀▀█░▌▐░█▀▀▀▀▀▀▀█░▌          ▐░▌     ▐░▌     ▐░▌   ▐░▌ ▐░▌ ▀▀▀▀▀▀▀▀▀█░▌▐░█▀▀▀▀▀▀▀▀▀ ▐░█▀▀▀▀▀▀▀▀▀ ▐░▌               ▐░▌     
          ▐░▌▐░▌       ▐░▌          ▐░▌     ▐░▌     ▐░▌    ▐░▌▐░▌          ▐░▌▐░▌          ▐░▌          ▐░▌               ▐░▌     
 ▄▄▄▄▄▄▄▄▄█░▌▐░█▄▄▄▄▄▄▄█░▌ ▄▄▄▄▄▄▄▄▄█░▌ ▄▄▄▄█░█▄▄▄▄ ▐░▌     ▐░▐░▌ ▄▄▄▄▄▄▄▄▄█░▌▐░▌          ▐░█▄▄▄▄▄▄▄▄▄ ▐░█▄▄▄▄▄▄▄▄▄      ▐░▌     
▐░░░░░░░░░░░▌▐░░░░░░░░░░░▌▐░░░░░░░░░░░▌▐░░░░░░░░░░░▌▐░▌      ▐░░▌▐░░░░░░░░░░░▌▐░▌          ▐░░░░░░░░░░░▌▐░░░░░░░░░░░▌     ▐░▌     
 ▀▀▀▀▀▀▀▀▀▀▀  ▀▀▀▀▀▀▀▀▀▀▀  ▀▀▀▀▀▀▀▀▀▀▀  ▀▀▀▀▀▀▀▀▀▀▀  ▀        ▀▀  ▀▀▀▀▀▀▀▀▀▀▀  ▀            ▀▀▀▀▀▀▀▀▀▀▀  ▀▀▀▀▀▀▀▀▀▀▀       ▀      
365Inspect - The M365 Environment Audit Tool                    
Version 0.0.5+Beta - Leonardo van de Weteringh
"@

  $banner3 = @"

 ::::::::   ::::::::  :::::::::: ::::::::::: ::::    :::  ::::::::  :::::::::  :::::::::: :::::::: ::::::::::: 
:+:    :+: :+:    :+: :+:    :+:     :+:     :+:+:   :+: :+:    :+: :+:    :+: :+:       :+:    :+:    :+:     
       +:+ +:+        +:+            +:+     :+:+:+  +:+ +:+        +:+    +:+ +:+       +:+           +:+     
    +#++:  +#++:++#+  +#++:++#+      +#+     +#+ +:+ +#+ +#++:++#++ +#++:++#+  +#++:++#  +#+           +#+     
       +#+ +#+    +#+        +#+     +#+     +#+  +#+#+#        +#+ +#+        +#+       +#+           +#+     
#+#    #+# #+#    #+# #+#    #+#     #+#     #+#   #+#+# #+#    #+# #+#        #+#       #+#    #+#    #+#     
 ########   ########   ########  ########### ###    ####  ########  ###        ########## ########     ###     
365Inspect - The M365 Environment Audit Tool                    
Version 0.0.5+Beta - Leonardo van de Weteringh
"@
  $banner = @($banner1,$banner2,$banner3)
  $bannernumber = (Get-Random -Maximum $banner.length)
  Write-Host ($banner[$bannernumber]) -ForegroundColor Yellow
}

function Main {
  Banner
  CheckAdminPrivBeta #First Checking Admin
  CheckInstalledModules #Check Install Modules + Updates + Uninstall only earlier versions
  Connect-Services #Connect to Services!
  ExecuteInspectors
  SaveFile
  DisconnectServices
}
Main
return
